'use webmcp-tool v1';

export const metadata = {
  name: 'youtube_transcript',
  namespace: 'agentboard',
  version: '1.0.0',
  description: 'Extract transcript and metadata from the current YouTube video. Returns title, author, duration, description, view count, and full transcript with timestamps.',
  match: ['*://www.youtube.com/watch*', '*://youtube.com/watch*'],
  inputSchema: {
    type: 'object',
    properties: {
      language: {
        type: 'string',
        description: 'Preferred language code (e.g., "en", "es"). Defaults to English or first available.'
      },
      format: {
        type: 'string',
        enum: ['segments', 'text'],
        description: '"segments" returns timestamped array, "text" returns concatenated plain text. Default: "segments"'
      }
    },
    additionalProperties: false
  }
};

export async function execute(args = {}) {
  const videoId = new URL(window.location.href).searchParams.get('v');
  if (!videoId) {
    throw new Error('Not on a YouTube video page (no video ID found)');
  }

  // Always fetch fresh playerResponse via Innertube API.
  // We can't use window.ytInitialPlayerResponse because the caption URLs
  // contain signatures and expiry timestamps that become stale.
  const playerResponse = await fetchPlayerResponseViaInnertube(videoId);

  if (!playerResponse) {
    throw new Error('Could not retrieve video data from YouTube');
  }

  // Extract video metadata
  const videoDetails = playerResponse.videoDetails || {};
  const metadata = {
    videoId,
    title: videoDetails.title || '',
    author: videoDetails.author || '',
    channelId: videoDetails.channelId || '',
    lengthSeconds: parseInt(videoDetails.lengthSeconds, 10) || 0,
    viewCount: parseInt(videoDetails.viewCount, 10) || 0,
    description: videoDetails.shortDescription || '',
    keywords: videoDetails.keywords || [],
    isLive: videoDetails.isLiveContent || false
  };

  // Extract caption tracks
  const captionTracks = playerResponse?.captions?.playerCaptionsTracklistRenderer?.captionTracks;
  if (!captionTracks?.length) {
    // Return metadata even if no captions available
    return {
      metadata,
      transcript: null,
      error: 'No captions available for this video'
    };
  }

  // Prefer manual captions over auto-generated (ASR)
  // Manual captions don't have 'kind' field, auto-generated have kind: 'asr'
  const manualTracks = captionTracks.filter(t => !t.kind);
  const tracksToSearch = manualTracks.length > 0 ? manualTracks : captionTracks;

  // Select language: prefer requested, then English, then first available
  const preferredLang = args.language || 'en';
  const selectedTrack =
    tracksToSearch.find(t => t.languageCode === preferredLang) ||
    tracksToSearch.find(t => t.languageCode.startsWith(preferredLang)) ||
    tracksToSearch.find(t => t.languageCode.startsWith('en')) ||
    tracksToSearch[0];

  // Fetch transcript as JSON (fmt=json3) to avoid XML parsing and Trusted Types CSP issues
  const jsonUrl = selectedTrack.baseUrl + '&fmt=json3';
  const transcriptResponse = await fetch(jsonUrl, { credentials: 'include' });

  if (!transcriptResponse.ok) {
    throw new Error(`Failed to fetch transcript: ${transcriptResponse.status}`);
  }

  const transcriptData = await transcriptResponse.json();

  // Parse JSON format into segments
  const segments = parseTranscriptJson(transcriptData);

  // Build transcript object
  const transcript = {
    language: selectedTrack.languageCode,
    languageName: selectedTrack.name?.simpleText || selectedTrack.languageCode,
    isAutoGenerated: selectedTrack.kind === 'asr',
    segmentCount: segments.length
  };

  if (args.format === 'text') {
    transcript.text = segments.map(s => s.text).join(' ');
  } else {
    transcript.segments = segments;
  }

  return { metadata, transcript };
}


/**
 * Fetch player response via YouTube's Innertube API.
 * This is the internal API YouTube uses for its own player.
 */
async function fetchPlayerResponseViaInnertube(videoId) {
  // Extract API key from page HTML
  const html = document.documentElement.outerHTML;
  const apiKeyMatch = html.match(/"INNERTUBE_API_KEY":"([^"]+)"/);
  if (!apiKeyMatch) {
    throw new Error('Could not find YouTube API key on page');
  }

  const apiKey = apiKeyMatch[1];
  const innertubeUrl = `https://www.youtube.com/youtubei/v1/player?key=${apiKey}`;

  const response = await fetch(innertubeUrl, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      context: {
        client: {
          clientName: 'WEB',
          clientVersion: '2.20250101.00.00'
        }
      },
      videoId
    })
  });

  if (!response.ok) {
    throw new Error(`Innertube API request failed: ${response.status}`);
  }

  return response.json();
}

/**
 * Parse YouTube's JSON transcript format (fmt=json3) into structured segments.
 * JSON format has events with segs arrays containing utf8 text.
 */
function parseTranscriptJson(data) {
  const segments = [];

  if (!data.events) {
    return segments;
  }

  for (const event of data.events) {
    // Skip events without segments (e.g., format markers)
    if (!event.segs) continue;

    // Concatenate all segment text
    const text = event.segs
      .map(seg => seg.utf8 || '')
      .join('')
      .trim();

    if (text) {
      segments.push({
        start: (event.tStartMs || 0) / 1000,
        duration: (event.dDurationMs || 0) / 1000,
        text
      });
    }
  }

  return segments;
}
